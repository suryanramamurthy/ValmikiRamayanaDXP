"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getData = void 0;
const tslib_1 = require("tslib");
const param_serializer_1 = require("./param-serializer");
const api_error_1 = require("./api-error");
const error_messages_1 = require("./error-messages");
/**
 * Handles array parameters properly with & separators
 * React Native compatible implementation without URLSearchParams.set()
 */
function serializeParams(params) {
    if (!params)
        return '';
    return (0, param_serializer_1.serialize)(params);
}
/**
 * Builds the full URL with query parameters
 */
function buildFullUrl(baseURL, url, queryString) {
    if (url.startsWith('http://') || url.startsWith('https://')) {
        return `${url}?${queryString}`;
    }
    const base = baseURL || '';
    return `${base}${url}?${queryString}`;
}
/**
 * Makes the HTTP request with proper URL handling
 */
function makeRequest(instance, url, requestConfig, actualFullUrl) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // If URL is too long, use direct axios request with full URL
        if (actualFullUrl.length > 2000) {
            return yield instance.request({
                method: 'get',
                url: actualFullUrl,
                headers: instance.defaults.headers,
                maxContentLength: Infinity,
                maxBodyLength: Infinity,
            });
        }
        else {
            return yield instance.get(url, requestConfig);
        }
    });
}
/**
 * Handles and formats errors from Axios requests
 * @param err - The error object from Axios
 * @returns Formatted error object with meaningful information
 */
function handleRequestError(err) {
    return api_error_1.APIError.fromAxiosError(err);
}
function getData(instance, url, data) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            if (instance.stackConfig && instance.stackConfig.live_preview) {
                const livePreviewParams = instance.stackConfig.live_preview;
                if (livePreviewParams.enable) {
                    data.live_preview = livePreviewParams.live_preview || 'init';
                }
                if (livePreviewParams.preview_token) {
                    instance.defaults.headers.preview_token = livePreviewParams.preview_token;
                    instance.defaults.headers.live_preview = livePreviewParams.live_preview;
                }
                if (livePreviewParams.enable) {
                    // adds protocol so host is replaced and not appended
                    if (livePreviewParams.live_preview && livePreviewParams.live_preview !== 'init') {
                        if (!livePreviewParams.host) {
                            throw new Error(error_messages_1.ERROR_MESSAGES.REQUEST.HOST_REQUIRED_FOR_LIVE_PREVIEW);
                        }
                        url = (livePreviewParams.host.startsWith('https://') ? '' : 'https://') + livePreviewParams.host + url;
                    }
                }
            }
            const requestConfig = Object.assign(Object.assign({}, data), { maxContentLength: Infinity, maxBodyLength: Infinity });
            const queryString = serializeParams(requestConfig.params);
            const actualFullUrl = buildFullUrl(instance.defaults.baseURL, url, queryString);
            const response = yield makeRequest(instance, url, requestConfig, actualFullUrl);
            if (response && response.data) {
                return response.data;
            }
            else {
                throw response;
            }
        }
        catch (err) {
            throw handleRequestError(err);
        }
    });
}
exports.getData = getData;
//# sourceMappingURL=request.js.map