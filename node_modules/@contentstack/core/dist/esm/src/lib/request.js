import { __awaiter } from "tslib";
import { serialize } from './param-serializer.js';
import { APIError } from './api-error.js';
import { ERROR_MESSAGES } from './error-messages.js';
/**
 * Handles array parameters properly with & separators
 * React Native compatible implementation without URLSearchParams.set()
 */
function serializeParams(params) {
    if (!params)
        return '';
    return serialize(params);
}
/**
 * Builds the full URL with query parameters
 */
function buildFullUrl(baseURL, url, queryString) {
    if (url.startsWith('http://') || url.startsWith('https://')) {
        return `${url}?${queryString}`;
    }
    const base = baseURL || '';
    return `${base}${url}?${queryString}`;
}
/**
 * Makes the HTTP request with proper URL handling
 */
function makeRequest(instance, url, requestConfig, actualFullUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        // If URL is too long, use direct axios request with full URL
        if (actualFullUrl.length > 2000) {
            return yield instance.request({
                method: 'get',
                url: actualFullUrl,
                headers: instance.defaults.headers,
                maxContentLength: Infinity,
                maxBodyLength: Infinity,
            });
        }
        else {
            return yield instance.get(url, requestConfig);
        }
    });
}
/**
 * Handles and formats errors from Axios requests
 * @param err - The error object from Axios
 * @returns Formatted error object with meaningful information
 */
function handleRequestError(err) {
    return APIError.fromAxiosError(err);
}
export function getData(instance, url, data) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (instance.stackConfig && instance.stackConfig.live_preview) {
                const livePreviewParams = instance.stackConfig.live_preview;
                if (livePreviewParams.enable) {
                    data.live_preview = livePreviewParams.live_preview || 'init';
                }
                if (livePreviewParams.preview_token) {
                    instance.defaults.headers.preview_token = livePreviewParams.preview_token;
                    instance.defaults.headers.live_preview = livePreviewParams.live_preview;
                }
                if (livePreviewParams.enable) {
                    // adds protocol so host is replaced and not appended
                    if (livePreviewParams.live_preview && livePreviewParams.live_preview !== 'init') {
                        if (!livePreviewParams.host) {
                            throw new Error(ERROR_MESSAGES.REQUEST.HOST_REQUIRED_FOR_LIVE_PREVIEW);
                        }
                        url = (livePreviewParams.host.startsWith('https://') ? '' : 'https://') + livePreviewParams.host + url;
                    }
                }
            }
            const requestConfig = Object.assign(Object.assign({}, data), { maxContentLength: Infinity, maxBodyLength: Infinity });
            const queryString = serializeParams(requestConfig.params);
            const actualFullUrl = buildFullUrl(instance.defaults.baseURL, url, queryString);
            const response = yield makeRequest(instance, url, requestConfig, actualFullUrl);
            if (response && response.data) {
                return response.data;
            }
            else {
                throw response;
            }
        }
        catch (err) {
            throw handleRequestError(err);
        }
    });
}
//# sourceMappingURL=request.js.map