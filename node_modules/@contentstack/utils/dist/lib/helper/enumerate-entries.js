var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { nodeToMetadata } from '../Models/metadata-model';
import MarkType from '../nodes/mark-type';
import { defaultNodeOption } from '../options/default-node-options';
import { findRenderString } from './find-embeded-object';
import { replaceHtmlEntities } from './string-utils';
export function enumerate(entries, process) {
    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
        var entry = entries_1[_i];
        process(entry);
    }
}
export function enumerateContents(content, renderOption, renderEmbed) {
    if (!(content instanceof Array) && content.type !== 'doc') {
        return content;
    }
    if (content instanceof Array) {
        var result_1 = [];
        content.forEach(function (doc) {
            result_1.push(enumerateContents(doc, renderOption, renderEmbed));
        });
        return result_1;
    }
    var commonRenderOption = __assign(__assign({}, defaultNodeOption), renderOption);
    return nodeChildrenToHTML(content.children, commonRenderOption, renderEmbed);
}
export function textNodeToHTML(node, renderOption) {
    var text = replaceHtmlEntities(node.text);
    // Convert newlines to <br /> tags if there are no other marks
    // This ensures newlines are always handled consistently
    var hasMarks = false;
    if (node.classname || node.id) {
        text = renderOption[MarkType.CLASSNAME_OR_ID](text, node.classname, node.id);
        hasMarks = true;
    }
    if (node.break) {
        text = renderOption[MarkType.BREAK](text);
        hasMarks = true;
    }
    if (node.superscript) {
        text = renderOption[MarkType.SUPERSCRIPT](text);
        hasMarks = true;
    }
    if (node.subscript) {
        text = renderOption[MarkType.SUBSCRIPT](text);
        hasMarks = true;
    }
    if (node.inlineCode) {
        text = renderOption[MarkType.INLINE_CODE](text);
        hasMarks = true;
    }
    if (node.strikethrough) {
        text = renderOption[MarkType.STRIKE_THROUGH](text);
        hasMarks = true;
    }
    if (node.underline) {
        text = renderOption[MarkType.UNDERLINE](text);
        hasMarks = true;
    }
    if (node.italic) {
        text = renderOption[MarkType.ITALIC](text);
        hasMarks = true;
    }
    if (node.bold) {
        text = renderOption[MarkType.BOLD](text);
        hasMarks = true;
    }
    // If no marks were applied, but text contains newlines, convert them to <br />
    if (!hasMarks && text.includes('\n')) {
        text = text.replace(/\n/g, '<br />');
    }
    return text;
}
export function referenceToHTML(node, renderOption, renderEmbed) {
    function sendToRenderOption(referenceNode) {
        var next = function (nodes) { return nodeChildrenToHTML(nodes, renderOption, renderEmbed); };
        return renderOption[referenceNode.type](referenceNode, next);
    }
    if ((node.attrs.type === 'entry' || node.attrs.type === 'asset') && node.attrs['display-type'] === 'link') {
        var entryText = node.children ? nodeChildrenToHTML(node.children, renderOption, renderEmbed) : '';
        if (renderOption[node.type] !== undefined) {
            return sendToRenderOption(node);
        }
        var href = node.attrs.href || node.attrs.url;
        var aTagAttrs = "".concat(node.attrs.style ? " style=\"".concat(node.attrs.style, "\"") : "").concat(node.attrs['class-name'] ? " class=\"".concat(node.attrs['class-name'], "\"") : "").concat(node.attrs.id ? " id=\"".concat(node.attrs.id, "\"") : "").concat(href ? " href=\"".concat(href, "\"") : "");
        if (node.attrs.target) {
            aTagAttrs += " target=\"".concat(node.attrs.target, "\"");
        }
        if (node.attrs.type == 'asset') {
            aTagAttrs += " type=\"asset\" content-type-uid=\"sys_assets\" ".concat(node.attrs['asset-uid'] ? "data-sys-asset-uid=\"".concat(node.attrs['asset-uid'], "\"") : "", " sys-style-type=\"download\"");
        }
        var aTag = "<a".concat(aTagAttrs, ">").concat(entryText, "</a>");
        return aTag;
    }
    if (!renderEmbed && renderOption[node.type] !== undefined) {
        return sendToRenderOption(node);
    }
    if (!renderEmbed) {
        return '';
    }
    var metadata = nodeToMetadata(node.attrs, (node.children && node.children.length > 0 ? node.children[0] : {}));
    var item = renderEmbed(metadata);
    if (!item && renderOption[node.type] !== undefined) {
        return sendToRenderOption(node);
    }
    return findRenderString(item, metadata, renderOption);
}
function nodeChildrenToHTML(nodes, renderOption, renderEmbed) {
    return nodes.map(function (node) { return nodeToHTML(node, renderOption, renderEmbed); }).join('');
}
function styleObjectToString(styleObj) {
    if (!styleObj)
        return '';
    if (typeof styleObj === 'string') {
        return styleObj;
    }
    var styleString = '';
    for (var key in styleObj) {
        if (styleObj.hasOwnProperty(key)) {
            var value = styleObj[key];
            styleString += "".concat(key, ":").concat(value, ";");
        }
    }
    return styleString;
}
function nodeToHTML(node, renderOption, renderEmbed) {
    var _a;
    if ((_a = node === null || node === void 0 ? void 0 : node.attrs) === null || _a === void 0 ? void 0 : _a.style) {
        node.attrs.style = styleObjectToString(node.attrs.style);
    }
    if (!node.type) {
        return textNodeToHTML(node, renderOption);
    }
    else if (node.type === 'reference') {
        return referenceToHTML(node, renderOption, renderEmbed);
    }
    else {
        var next = function (nodes) { return nodeChildrenToHTML(nodes, renderOption, renderEmbed); };
        if (renderOption[node.type] !== undefined) {
            return renderOption[node.type](node, next);
        }
        else {
            return renderOption.default(node, next);
        }
    }
}
//# sourceMappingURL=enumerate-entries.js.map