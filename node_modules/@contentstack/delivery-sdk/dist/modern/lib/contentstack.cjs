"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/contentstack.ts
var contentstack_exports = {};
__export(contentstack_exports, {
  Utils: () => Utils,
  stack: () => stack
});
module.exports = __toCommonJS(contentstack_exports);
var import_core = require("@contentstack/core");
var import_cache = require("./cache.cjs");
var import_stack = require("./stack.cjs");
var import_types = require("./types.cjs");
var Utility = __toESM(require("./utils.cjs"), 1);
var Utils = __toESM(require("@contentstack/utils"), 1);
var version = "{{VERSION}}";
function stack(config) {
  const DEFAULT_HOST = Utility.getHostforRegion(config.region || import_types.Region.US, config.host);
  let defaultConfig = {
    defaultHostname: DEFAULT_HOST,
    headers: {},
    params: {},
    live_preview: {},
    port: config.port,
    ...config
  };
  config.host = defaultConfig.defaultHostname;
  if (config.apiKey) {
    defaultConfig.headers.api_key = config.apiKey;
  } else {
    throw new Error("API key for Stack is required.");
  }
  if (config.deliveryToken) {
    defaultConfig.headers.access_token = config.deliveryToken;
  } else {
    throw new Error("Delivery token for Stack is required.");
  }
  if (config.environment) {
    defaultConfig.params.environment = config.environment;
  } else {
    throw new Error("Environment for Stack is required");
  }
  if (config.locale) {
    defaultConfig.params.locale = config.locale;
  }
  if (config.live_preview) {
    if (Utility.isBrowser()) {
      const params = new URL(document.location.toString()).searchParams;
      if (params.has("live_preview")) {
        config.live_preview.live_preview = params.get("live_preview") || config.live_preview.live_preview;
      }
      if (params.has("release_id")) {
        defaultConfig.headers["release_id"] = params.get("release_id");
      }
      if (params.has("preview_timestamp")) {
        defaultConfig.headers["preview_timestamp"] = params.get("preview_timestamp");
      }
    }
  }
  if (config.branch) {
    defaultConfig.headers.branch = config.branch;
  }
  if (config.early_access) {
    defaultConfig.headers["x-header-ea"] = config.early_access.join(",");
  }
  defaultConfig.headers["X-User-Agent"] = "contentstack-delivery-typescript/" + version;
  const client = (0, import_core.httpClient)(defaultConfig);
  if (config.logHandler) client.defaults.logHandler = config.logHandler;
  if (config.cacheOptions && config.cacheOptions.policy !== import_types.Policy.IGNORE_CACHE) {
    const defaultAdapter = client.defaults.adapter;
    client.defaults.adapter = (adapterConfig) => {
      return new Promise(async (resolve, reject) => {
        if (config.cacheOptions)
          await (0, import_cache.handleRequest)(config.cacheOptions, config.apiKey, defaultAdapter, resolve, reject, adapterConfig);
      });
    };
  }
  if (config.debug) {
    client.interceptors.request.use((requestConfig) => {
      config.logHandler("info", {
        type: "request",
        method: requestConfig.method?.toUpperCase(),
        url: requestConfig.url,
        headers: requestConfig.headers,
        params: requestConfig.params,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      return requestConfig;
    });
    client.interceptors.response.use(
      (response) => {
        const level = getLogLevelFromStatus(response.status);
        config.logHandler(level, {
          type: "response",
          status: response.status,
          statusText: response.statusText,
          url: response.config?.url,
          method: response.config?.method?.toUpperCase(),
          headers: response.headers,
          data: response.data,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        return response;
      },
      (error) => {
        const status = error.response?.status || 0;
        const level = getLogLevelFromStatus(status);
        config.logHandler(level, {
          type: "response_error",
          status,
          statusText: error.response?.statusText || error.message,
          url: error.config?.url,
          method: error.config?.method?.toUpperCase(),
          error: error.message,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        throw error;
      }
    );
  }
  function getLogLevelFromStatus(status) {
    if (status >= 200 && status < 300) {
      return "info";
    } else if (status >= 300 && status < 400) {
      return "warn";
    } else if (status >= 400) {
      return "error";
    } else {
      return "debug";
    }
  }
  const errorHandler = (error) => {
    return (0, import_core.retryResponseErrorHandler)(error, config, client);
  };
  client.interceptors.request.use(import_core.retryRequestHandler);
  client.interceptors.response.use(import_core.retryResponseHandler, errorHandler);
  if (config.plugins) {
    client.interceptors.request.use((reqConfig) => {
      if (config && config.plugins)
        config.plugins.forEach((pluginInstance) => {
          reqConfig = pluginInstance.onRequest(reqConfig);
        });
      return reqConfig;
    });
    client.interceptors.response.use((response) => {
      if (config && config.plugins)
        config.plugins.forEach((pluginInstance) => {
          response = pluginInstance.onResponse(response.request, response, response.data);
        });
      return response;
    });
  }
  return new import_stack.Stack(client, config);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Utils,
  stack
});
//# sourceMappingURL=contentstack.cjs.map