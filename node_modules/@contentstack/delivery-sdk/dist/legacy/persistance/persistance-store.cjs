"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/persistance/persistance-store.ts
var persistance_store_exports = {};
__export(persistance_store_exports, {
  PersistanceStore: () => PersistanceStore
});
module.exports = __toCommonJS(persistance_store_exports);
var import_local_storage = require("./storages/local-storage.cjs");
var import_memory_storage = require("./storages/memory-storage.cjs");
var import_error_messages = require("../lib/error-messages.cjs");
var PersistanceStore = class {
  /**
   * Creates a new PersistanceStore instance
   * @param {PersistanceStoreConfig} [config] - Configuration options for the store
   */
  constructor(config) {
    this.store = import_local_storage.localStorage;
    let defaultConfig = {
      storeType: "localStorage",
      maxAge: 1e3 * 60 * 60 * 24,
      serializer: JSON.stringify,
      deserializer: JSON.parse
    };
    defaultConfig = {
      ...defaultConfig,
      ...config
    };
    this.setStore(defaultConfig.storeType, defaultConfig.storage);
    this.config = defaultConfig;
    this.name = "";
  }
  setStore(type, store) {
    switch (type) {
      case "localStorage":
        break;
      case "memoryStorage":
        this.store = import_memory_storage.memoryStorage;
        break;
      case "customStorage":
        if (!store) {
          throw new TypeError(import_error_messages.ErrorMessages.MISSING_CUSTOM_STORAGE);
        } else {
          this.store = store;
        }
        break;
    }
  }
  /**
   * Sets an item in the store with optional expiration
   * @param {string} key - The key to store the value under
   * @param {any} value - The value to store
   * @param {string} [contentTypeUid] - Optional content type UID for key scoping
   * @param {number} [maxAge] - Optional maximum age in milliseconds (overrides config maxAge)
   */
  setItem(key, value, contentTypeUid, maxAge) {
    if (!key) {
      return;
    }
    const generatedKey = this.generateCSKey(key, contentTypeUid);
    if (!value) {
      this.store.removeItem(generatedKey);
      return;
    }
    const expiry = this.calculateExpiry(maxAge);
    let content = { value, expiry };
    if (this.config.serializer) {
      content = this.config.serializer(content);
    }
    this.store.setItem(generatedKey, content);
  }
  /**
   * Gets an item from the store if it exists and hasn't expired
   * @param {string} key - The key to retrieve
   * @param {string} [contentTypeUid] - Optional content type UID for key scoping
   * @returns {any} The stored value if found and not expired, undefined otherwise
   */
  getItem(key, contentTypeUid) {
    const generatedKey = this.generateCSKey(key, contentTypeUid);
    const content = this.store.getItem(generatedKey);
    if (content) {
      if (this.config.deserializer) {
        const item = this.config.deserializer(content);
        if (!this.isExpire(item.expiry)) {
          return item.value;
        } else {
          this.removeItem(key, contentTypeUid);
        }
      }
    }
  }
  /**
   * Removes an item from the store
   * @param {string} key - The key to remove
   * @param {string} [contentTypeUid] - Optional content type UID for key scoping
   */
  removeItem(key, contentTypeUid) {
    const generatedKey = this.generateCSKey(key, contentTypeUid);
    this.store.removeItem(generatedKey);
  }
  /**
   * Clears all items from the store, or items matching a specific content type UID
   * @param {string} [contentTypeUid] - Optional content type UID to clear only matching items
   */
  clear(contentTypeUid) {
    if (!contentTypeUid) {
      this.store.clear();
    } else {
      this.store.each((_, key) => {
        if (key.match(contentTypeUid)) {
          this.store.removeItem(key);
        }
      });
    }
  }
  generateCSKey(key, contentTypeUid) {
    let keyPrefix = "cs_store_js";
    if (contentTypeUid) {
      keyPrefix = contentTypeUid + "_" + keyPrefix;
    }
    keyPrefix = this.name + "_" + keyPrefix + "_" + key;
    return keyPrefix;
  }
  calculateExpiry(maxAge) {
    const now = /* @__PURE__ */ new Date();
    const nowMSec = now.getTime();
    if (maxAge) {
      return nowMSec + maxAge;
    } else if (this.config.maxAge) {
      return nowMSec + this.config.maxAge;
    }
    return 0;
  }
  isExpire(dateTime) {
    if (dateTime) {
      return dateTime < (/* @__PURE__ */ new Date()).getTime();
    }
    return true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PersistanceStore
});
//# sourceMappingURL=persistance-store.cjs.map