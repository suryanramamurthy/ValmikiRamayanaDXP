"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/cache.ts
var cache_exports = {};
__export(cache_exports, {
  handleRequest: () => handleRequest
});
module.exports = __toCommonJS(cache_exports);
var import_persistance = require("../persistance/index.cjs");
var import_types = require("./types.cjs");
function extractEntryUidFromUrl(config) {
  if (!config.url) return null;
  const entryUrlPattern = /\/content_types\/[^\/]+\/entries\/([^\/\?]+)/;
  const match = config.url.match(entryUrlPattern);
  return match ? match[1] : null;
}
function generateEnhancedCacheKey(originalKey, contentTypeUid, entryUid) {
  let cacheKey = originalKey;
  if (contentTypeUid) {
    cacheKey = `${contentTypeUid}_${cacheKey}`;
  }
  if (entryUid) {
    cacheKey = `${cacheKey}_entry_${entryUid}`;
  }
  return cacheKey;
}
async function handleRequest(cacheOptions, apiKey, defaultAdapter, resolve, reject, config) {
  const cacheStore = new import_persistance.PersistanceStore(cacheOptions);
  const entryUid = config.entryUid || extractEntryUidFromUrl(config);
  const enhancedCacheKey = generateEnhancedCacheKey(apiKey, config.contentTypeUid, entryUid);
  switch (cacheOptions.policy) {
    case import_types.Policy.NETWORK_ELSE_CACHE: {
      const apiResponse = await defaultAdapter(config);
      if (apiResponse.data) {
        cacheStore.setItem(enhancedCacheKey, JSON.parse(apiResponse.data), config.contentTypeUid, cacheOptions.maxAge);
        return resolve({ data: JSON.parse(apiResponse.data) });
      } else {
        const cacheResponse = cacheStore.getItem(enhancedCacheKey, config.contentTypeUid);
        if (cacheResponse)
          return resolve({
            data: cacheResponse,
            status: 200,
            statusText: "OK",
            headers: {},
            config: {}
          });
      }
      return reject(apiResponse);
    }
    case import_types.Policy.CACHE_THEN_NETWORK: {
      const cacheResponse = cacheStore.getItem(enhancedCacheKey, config.contentTypeUid);
      if (cacheResponse)
        return resolve({
          data: cacheResponse,
          status: 200,
          statusText: "OK",
          headers: {},
          config: {}
        });
      const apiResponse = await defaultAdapter(config);
      if (apiResponse.data) {
        cacheStore.setItem(enhancedCacheKey, JSON.parse(apiResponse.data), config.contentTypeUid, cacheOptions.maxAge);
        return resolve({ data: JSON.parse(apiResponse.data) });
      } else {
        return reject(apiResponse);
      }
    }
    case import_types.Policy.CACHE_ELSE_NETWORK: {
      const cacheResponse = cacheStore.getItem(enhancedCacheKey, config.contentTypeUid);
      if (cacheResponse)
        return resolve({
          data: cacheResponse,
          status: 200,
          statusText: "OK",
          headers: {},
          config: {}
        });
      else {
        const apiResponse = await defaultAdapter(config);
        if (apiResponse.data) {
          cacheStore.setItem(enhancedCacheKey, JSON.parse(apiResponse.data), config.contentTypeUid, cacheOptions.maxAge);
          return resolve({ data: JSON.parse(apiResponse.data) });
        } else {
          return reject(apiResponse);
        }
      }
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handleRequest
});
//# sourceMappingURL=cache.cjs.map